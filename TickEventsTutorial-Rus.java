/**
 * 1.7.x TickEvents и Создание TickHandler
 */
 
/**
 * Создатель оригинала туториала (eng): coolAlias
 * Перевел на русский: keelfy
 * Об ошибках, вопросах и предложениях о переводе писать сюда: http://vk.com/tehnyla
 */
 
/**
 *	P.S. (сделаю оговорку о переводе, чтобы все понимали что за обработчики тиков)
 *		Обработчик Тиков / Тикер  	= Ticker / TickHandler
 *		Событие 					= Event
 *      Потиковое событие 			= TickEvent
 *      Шина Событий  				= Event Bus
 *		Слушатель Событий   		= Метод с событием в параметре и с аннотацией @ForgeSubscribe (1.6 и ранее) или @SubcribeEvent (1.7+)
 */
 
/*
		СТОП!!! Скорее всего, вам не нужно создавать обработчик тиков в зависимости от того, что вы делаете. 
	Есть много встроенных обработчиков тиков, встроенных в ванилу, всегда стоит использовать из, если вы можете. Почему? 
	Потому что они работают только тогда, когда рассматриваемый объект существует, в то время как общий обработчик работает внезависимости от этого.
	
	Вот некоторые готовые тикеры:
		Entity#onUpdate: вызывается каждый тик для определенного существа; чтобы управлять ванильными существами, используйте LivingUpdateEvent.
		TileEntity#onUpdate: вызывается для TileEntity каждый тик, если вы не запретили ему вызываться.
		Item#onUpdate: вызывается каждый тик, пока определенный предмет в инвентаре игрока.
		Item#onArmorTick: вызывается каждый тик для брони, пока она экипирована
		Block#updateTick: может вызываться случайно, основываясь на тактовой частоте блока или может вызываться по расписанию
		
		Как вы видите, если вы хотели бы что-то сделать каждый тик, то сделать это можно без своего обработчика. Если вы хотите сделать что-то, что 
	не может быть сделано встроенными тикерами, тогда только после того, как вы поняли этого можно создавать обработчик.
	
		В 1.7.х, я уверен, некоторые из вас заметили, что класс TickHandler из 1.6 заменился одним TickEvent'ом. Так что же нужно прописать, 
	чтобы получить у нового события такую же функциональность, как у устаревшего класса? Ниже я расписал что нужно делать и как сделать это более эффективно.
*/

/**
 * Часть 1: Определите какое потиковое событие использовать
 */
 
/*
	В игре есть пять разных типов потикового события, каждый из которых вызывает разные игровые тики и работает на разных сторонах (клиент/сервер):
		ServerTickEvent: работает только на серверной части
		ClientTickEvent: работает только на клиентской части
		WorldTickEvent: работает на обоих сторонах
		PlayerTickEvent: работает на обо сторонах
		RenderTickEvent: работает только на клиентской части и вызывается при каждом тике рендеринга
		
	При создании обработчика, не забудьте указать определенный тип, иначе, если вы напишипе просто TickEvent, то будут обновляться все тики, что будет тормозить систему.
	После выбора нужного типа, можно приступать к созданию класса.
*/

/**
 * Часть 2: Создание TickHandler'а
 */
 
/*
	В туториале я буду назвать обработчик старым названим "TickHandler", хотя првильно "TickEvent".
	В качестве примера я возьму RenderTickEvent.
*/

// RenderTick только клиентское событие и можно поставить здесь аннотацию @SideOnly, если вы хотите.
@SideOnly(Side.CLIENT)
public class RenderTickHandler {
	// здесь нам нужен только один метод, вы можете его назвать как хотите, но
	// советую ставить название отображающее то, что именно обрабатывается каждый тик:
	@SubscribeEvent
	public void onRenderTick(RenderTickEvent event) {
		// здесь можно делать все что угодно каждый тик рендеринга, например, поворачить взгялд игрока
	}
}

/*
	Если вам нужно делать что-то либо в начале тика, либо в конце, вы можете проверить фазу тика в вашем методе. Применимо для всех потиковых событий.
*/

if (event.phase == Phase.START) {
	// начало тика
}
if (event.phase == Phase.END) {
	// конец тика
}

// если у вас многое происходит в одном методе, вы можете разделить фазу на методы:
@SubscribeEvent
public void onRenderTick(RenderTickEvent event) {
	if (event.phase == Phase.START) {
		onTickStart();
	} else {
		onTickEnd();
	}
}

/*
	Еще одна вещь, которую стоит упомянуть. Поскольку мы находимя на клиентской стороне мы используем Minecraft.getMinecraft() для доступа ко многим вещам,
	но это делать достаточно расточительно для системы, лучше делать так:
*/

@SideOnly(Side.CLIENT)
public class RenderTickHandler {
	/** Хранения экземпляра Minecraft для быстрого доступа */
	private Minecraft mc;

	// создание конструктора с параметром Minecraft; теперь у нас нужный нам класс когда угодно
	public RenderTickHandler(Minecraft mc) {
		this.mc = mc;
	}

	@SubscribeEvent
	public void onRenderTick(RenderTickEvent event) {
		if (event.phase == Phase.START) {
			// сделаем поворот игрока:
			mc.thePlayer.rotationYaw += 10.0F;
		}
	}
}

/**
 * Часть 3: регистрация вашего потикового обработчика
 */
 
/*
	Все потиковые обработчики должны быть зарегистрированы в шине событий FMLCommonHandler, НЕ в MinecraftForge EVENT_BUS. 
	Для нашего клиентского события мы будет регистрировать обработчик в ClientProxy, ибо если вы попытаетесь зарегистрировать его в 
	методе, обрабатываемом сервером, произойдет краш.
*/

public class CommonProxy {
/**
 * Не забудьте вызвать этот метод в главном классе моды в методе ' FMLPreInitializationEvent
 */
public void initialize() {
	// поскольку у нас нет обработчиков которые должны были бы работать на сервере, мы ничего не регистрируем здесь,
	// но если у вас WorldTickEvent или PlayerTickEvent, например, то их вам нужно регистрировать здесь
	// если вы попытаетесь зарегистрировать RenderTickHandler здесь, это вызывет краш
	}
}

public class ClientProxy extends CommonProxy {
	// Наш метод ClientProxy вызывается только на клиентской стороне, здесь можно безопастно зарегистрировать RenderTickHandler
	@Override
	public void initialize() {
	// нам нужно повторно зарегистрировать те обработчики, которые прописаны в CommonProxy
	// это важно, ибо CommonProxy регистрирует обработчики только на серверной части и вам нужно их зарегистрировать их также
	// на клиентской части; однако, мы не имеем серверных обработчиков
	super.initialize();

	// здесь производим регистрацию RenderTickHandler - убедитесь что вы прописали в параметр экземпляр класса Minecraft!
	FMLCommonHandler.instance().bus().register(new RenderTickHandler(Minecraft.getMinecraft()));

	// это, также, идеальное место для регистрации биндов (KeyBindings)
	}
}

/*
	Это все, что вам нужно знать о потиковых событиях для их эффективного использования. Запомните, никогда не прописывайте просто TickEvent
	прописывайте определенный тип потикового события, потому вам точно нужен только один из типов, а не все сразу.
	Приятного кодинга!
*/


